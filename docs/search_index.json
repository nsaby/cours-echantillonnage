[["index.html", "Cours sur les plans déchantillonnage statistique dans lespace pour létude des sols Chapter 1 Bienvenue", " Cours sur les plans déchantillonnage statistique dans lespace pour létude des sols Nicolas Saby, INRAe Infosol, Orléans France 2021-01-13 Chapter 1 Bienvenue This work by Nicolas Saby is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 United States License. "],["WHY.html", "Chapter 2 Pourquoi ce cours 2.1 Motivations 2.2 Définition 2.3 Contenu 2.4 Objectifs dune étude de sol 2.5 Léchantillonnage probabiliste vs non probabiliste 2.6 Approche basée sur un modèle ou basée sur un plan déchantillonnage 2.7 Population discrète et population continue 2.8 Plan 2.9 Libraries utilisées", " Chapter 2 Pourquoi ce cours Ces quelques notes de cours et de scripts R ont été produits pour un cours de M1 de la Faculté de Tours. https://master-environnement.univ-tours.fr/ Ce cours est basé sur les travaux publiés dans le livre (Gruijter et al. 2006). Un descriptif des approches utiles pour la cartographie est également disponible dans larticle de Brus et al (Brus 2019) ainsi que les scripts R associés sur le github: https://github.com/DickBrus/TutorialSampling4DSM Ce cours rassemble un sélection choisie de techniques et de codes ! 2.1 Motivations Les motivations pour ce cours sont les suivantes: Les cours de statistique classique ne sattardent pas sur la discipline de léchantillonnage La conception dun protocole déchantillonnage efficace et efficient est une première étape importante dun projet de recherche Le plan déchantillonnage détermine en grande partie la qualité du résultat final Les problèmes dinférence statistique peuvent souvent être évités lorsque la réflexion commence avant que les données ne soient collectées 2.2 Définition Le plan déchantillonnage dune enquête par sondage se réfère aux techniques utilisées pour sélectionner un échantillon probabiliste et aux méthodes utilisées pour obtenir des estimations des variables étudiées à partir de léchantillon sélectionné. On définit également lunité déchantillonnage qui correspond à la position dans lespace où des observations de sols vont être effectuées. AU doit de la position, il est possible deffectuer par exemple un sondage, une fosse ou un échantillon composite. 2.3 Contenu Proposer un aperçu des différents plans déchantillonnage pour létude des milieux naturles et notamment le sol. Connaissance des types de conception de base pour léchantillonnage probabiliste : avantages et inconvénients et des types de conception déchantillonnage dans lespace plus avancés Connaissance de la manière dont les informations annexes peuvent être utilisées dans le plan déchantillonnage ou dans linférence statistique. Connaissance de la manière dont les échantillons peuvent être sélectionnés dans R, et comment les paramètres statistiques peuvent être estimés Cela ne concerne pas la manière dont un plan déchantillonnage peut être évalué ex ante avant la collecte des données 2.4 Objectifs dune étude de sol Objectifs possibles de létude Pour estimer des statistiques sommaires (moyenne, total, proportion) ou la fonction de distribution cumulative spatiale (SCDF) pour létude la zone (population) dans son ensemble La même chose, mais maintenant pour plusieurs sous-domaines Pour cartographier la variable dintérêt Nous ne sommes pas intéressés par les changements au fil du temps La propriété dintérêt ne change pas pendant la période denquête 2.5 Léchantillonnage probabiliste vs non probabiliste Pour estimer les totaux ou les moyennes, léchantillonnage probabiliste est le plus approprié Par échantillonnage probabiliste, on entend un échantillonnage aléatoire tel que Toutes les unités de population ont une probabilité &gt; 0 dêtre sélectionnées Les probabilités dinclusion sont connues NB Les probabilités dinclusion ne doivent pas forcément être égales ! Il existe de nombreuses façons de sélectionner les unités de population avec un échantillonnage probabiliste Pour faire une carte par des techniques de modèlisation comme la géostatistique, un échantillonnage qui répartit bien les observations dans lespace géographique est plus approprié et tirer les positions au hasard nest pas nécessaire. 2.6 Approche basée sur un modèle ou basée sur un plan déchantillonnage Daprès le livre (Gruijter et al. 2006), la théorie de léchantillonnage sépare les techniques de sélection des unités déchantillonnage en deux grandes approches: Model based : Design based : lincertitude des estimateurs est calculée à partir des probabilités dinclusions 2.7 Population discrète et population continue Nous devons bien distinguer deux types de populations : Les populations discrètes : les objets naturels discrets correspondent naturellement aux unités déchantillonnage. Le nombre total dunités déchantillonnage dans la population (\\(N\\)) est finie Populations continues : les unités déchantillonnage doivent être définies, par exemple carrés de 1 km × 1 km Mais Nombre total dunités déchantillonnage dans une population continue peut être finie ou infinie Fini : tous les carrés disjoints de 1 km multipliés par 1 km dans une zone Infini : points dans une zone 2.8 Plan Ce cours présente ainsi dabord un ensemble de techniques relirées à léchantillonnage probabiliste. IL aborde également des techniques pour léchantillonnage pour la cartographie. Echantillonnage aléatoire simple Echantillonnage aléatoire stratifié Echantillonnage alétoire systématique Echanillonnage pour la cartographie 2.9 Libraries utilisées Ces notes ont été produites par RStudio en utilisant bookdown. Le site website est en ligne via github Netlify La version de ce livre numérique a été produite avec R version 4.0.2 (2020-06-22) et les package suivants: library(knitr) library(sp) library(tmap) library(rgdal) library(ggplot2) library(spcosa) # pour les algorithme de stratification de la zone library(fields) References "],["data.html", "Chapter 3 Données 3.1 Statistiques globales 3.2 Cartographie", " Chapter 3 Données 3.1 Statistiques globales Pour la partie sinteressant aux statistiques globales, nous basons nos exercices sur une réalité simulée dune valeur de carbone dans un parcelle agricole. Ce champ a été simulé en utilisant des techniques géostastitques. Lobjet correspond à un tableau comportant 3 colonnes. les coordonnées avec s1 et s2 les valeurs simulées sim1 Chaque coordonnée correspond au centre dun pixel champ &lt;- read.csv(&#39;data/simulatedField_1Exp25.csv&#39;) head(champ) ## s1 s2 sim1 ## 1 0.5 0.5 7.184881 ## 2 1.5 0.5 7.366762 ## 3 2.5 0.5 7.417718 ## 4 3.5 0.5 7.305573 ## 5 4.5 0.5 7.373427 ## 6 5.5 0.5 7.161203 Il est donc facile de transformer le tableau en une grille de type SpatialPixelsDataframe. Pour cela, on passe par une structure de type SpatialPointDataframe dans un premier temps. champSP &lt;- champ # transformer en un vecteur de points coordinates(champSP) &lt;- c(&#39;s1&#39;,&#39;s2&#39;) # transformer en raster gridded(champSP) &lt;- TRUE Voici la structure de lobjet de type sp. # structure de l&#39;objet str(champSP) ## Formal class &#39;SpatialPixelsDataFrame&#39; [package &quot;sp&quot;] with 7 slots ## ..@ data :&#39;data.frame&#39;: 10000 obs. of 1 variable: ## .. ..$ sim1: num [1:10000] 7.18 7.37 7.42 7.31 7.37 ... ## ..@ coords.nrs : num(0) ## ..@ grid :Formal class &#39;GridTopology&#39; [package &quot;sp&quot;] with 3 slots ## .. .. ..@ cellcentre.offset: Named num [1:2] 0.5 0.5 ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;s1&quot; &quot;s2&quot; ## .. .. ..@ cellsize : Named num [1:2] 1 1 ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;s1&quot; &quot;s2&quot; ## .. .. ..@ cells.dim : Named int [1:2] 100 100 ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;s1&quot; &quot;s2&quot; ## ..@ grid.index : int [1:10000] 9901 9902 9903 9904 9905 9906 9907 9908 9909 9910 ... ## ..@ coords : num [1:10000, 1:2] 0.5 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5 ... ## .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. ..$ : NULL ## .. .. ..$ : chr [1:2] &quot;s1&quot; &quot;s2&quot; ## ..@ bbox : num [1:2, 1:2] 0 0 100 100 ## .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. ..$ : chr [1:2] &quot;s1&quot; &quot;s2&quot; ## .. .. ..$ : chr [1:2] &quot;min&quot; &quot;max&quot; ## ..@ proj4string:Formal class &#39;CRS&#39; [package &quot;sp&quot;] with 1 slot ## .. .. ..@ projargs: chr NA Il est assez simple de faire une carte avec le package tmap tm_shape(champSP) + tm_raster()+ tm_layout(legend.outside = TRUE) ## Warning: The projection of the shape object champSP is not known, while it seems ## to be projected. ## Warning: Current projection of shape champSP unknown and cannot be determined. Figure 3.1: Notre réalité: un champ aléatoire simulé avec un variogramme de type exponentiel Lhistogramme de la propriété ressemble à ceci: ggplot(champ, aes(x=sim1)) + geom_histogram(bins = 50) Figure 3.2: Histogramme de la population La moyenne vraie de la population vaut ainsi Moy = mean(champ$sim1) Moy ## [1] 5.298602 3.2 Cartographie Pour illuster les différents plans possible pour la cartographie, nous prenons de jeus de données en exemple 3.2.1 Contour dune parcelle le contour dune parcelle est fourni par le package spcosa. Sa forme est complexe et permet de bien illustrer les caractéristiques des plans déchantillonnage proposés. shpFarmsum &lt;- readOGR(dsn = system.file(&quot;maps&quot;, package = &quot;spcosa&quot;), layer = &quot;farmsum&quot;) ## OGR data source with driver: ESRI Shapefile ## Source: &quot;D:\\nsaby\\R\\win-library\\4.0\\spcosa\\maps&quot;, layer: &quot;farmsum&quot; ## with 1 features ## It has 4 fields tm_shape(shpFarmsum) + tm_borders() Figure 3.3: Contour dune parcelle agricole 3.2.2 Covariables rasters en Australie Un ensemble de 5 rasters sont disponibles pour une parcelle située en Australie dans un zone viticole appelée Hunter vallée. Altitude lorientation de la pente pente indice de topographie lindice de végétation normalisé #Read data with coordinates and other attributes of fine grid (discretization of study area) load(file=&quot;Data/HunterValley4Practicals.RData&quot;) grdHunterValley2 &lt;- grdHunterValley coordinates(grdHunterValley2) &lt;- c(&#39;Easting&#39;,&#39;Northing&#39;) gridded(grdHunterValley2) &lt;- TRUE tm_shape(grdHunterValley2) + tm_raster(col = c(&quot;elevation_m&quot;,&quot;slope_deg&quot;,&quot;cti&quot;,&quot;ndvi&quot;) ) ## Variable(s) &quot;ndvi&quot; contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette. Figure 3.4: Covariables raster en Australie "],["SI.html", "Chapter 4 Echantillonnage aléatoire simple 4.1 Définition 4.2 Mise en oeuvre avec un logiciel 4.3 Calcul des estimateurs 4.4 Simulations", " Chapter 4 Echantillonnage aléatoire simple 4.1 Définition Les unités sont sélectionnées avec une probabilité égale et indépendamment les unes des autres ; également appelé échantillonnage aléatoire indépendant (IRS) Deux sous-types : avec remise (SIR) sans remise (SI) Cette distinction nest pas pertinente pour des populations infinies Toutes les combinaisons de \\(n\\) unités de population (tous les échantillons de \\(n\\) unités) ont une probabilité égale dêtre sélectionnés 4.2 Mise en oeuvre avec un logiciel 4.2.1 Excel Voici la procédure 4.2.2 Avec R pour les polutations discrètes Voici comment tirer au hasard des position dans lespace à partir de la liste des pixels. n = 20 #fixer la graine pour les tirages aléatoires set.seed(5602) # Creation des identifiants des lignes id = 1:10000 # ou id = seq( from = 1, to = 10000, by = 1) # tire au hasard n valeurs parmi 10000 MesIds &lt;- sample( x = id , size = n) MesIds &lt;- sort(MesIds) # Les coordonn?es champ[ MesIds , 1:2 ] ## s1 s2 ## 220 19.5 2.5 ## 286 85.5 2.5 ## 564 63.5 5.5 ## 1631 30.5 16.5 ## 1740 39.5 17.5 ## 2202 1.5 22.5 ## 2630 29.5 26.5 ## 3105 4.5 31.5 ## 3180 79.5 31.5 ## 4063 62.5 40.5 ## 5125 24.5 51.5 ## 6048 47.5 60.5 ## 6209 8.5 62.5 ## 6355 54.5 63.5 ## 7589 88.5 75.5 ## 7666 65.5 76.5 ## 7723 22.5 77.5 ## 7897 96.5 78.5 ## 8220 19.5 82.5 ## 9119 18.5 91.5 Il est possible alors dextraire les valeurs de carbone simulée pour les pixels tirés au hasard terrain1 &lt;- champ[ MesIds, &quot;sim1&quot; ] terrain1 ## [1] 5.088422 5.870447 4.565427 3.839903 4.177815 6.237273 5.100200 5.643163 ## [9] 6.107451 5.163339 5.708381 6.154790 6.040184 6.388020 6.277084 5.526610 ## [17] 6.171215 5.415374 6.536455 4.433357 4.2.3 Avec R pour les populations continues 1 Déterminer les coordonnées minimales et maximales s1 et s2 du domaine (boîte englobante) 2 Tirez deux coordonnées (pseudo-)aléatoires indépendantes \\(s_{1,v}\\) et \\(s_{2,aleat}\\) Utilisez une routine de point dans le polygone pour déterminer si (\\(s_{1,v}\\),\\(s_{2,aleat}\\)) tombe dans la zone Répétez les étapes 2 et 3 jusquà ce que n positions soient sélectionnées Le package sp offre la fonction spsample pour effectuer cette procédure à partir de couches SIG. MonEch &lt;- spsample( x = champSP , n = n , type = &quot;random&quot;) SI &lt;- tm_shape(champSP) + tm_raster()+ tm_shape(MonEch)+ tm_symbols()+ tm_layout(legend.outside = TRUE) SI ## Warning: The projection of the shape object champSP is not known, while it seems ## to be projected. ## Warning: Current projection of shape champSP unknown and cannot be determined. ## Warning: Current projection of shape MonEch unknown and cannot be determined. Figure 4.1: Exemple déchantillonnage aléatoire simple, avec 20 points SI(20) 4.3 Calcul des estimateurs Dans cette partie nous explorons les techniques pour calculer les estimateurs des paramètres statistiques à partir des données collectées. 4.3.1 lestimateur de Horvitz-Thompson Lestimateur H-T du total est \\(\\hat t = \\sum{z_i/\\pi_i}\\) Lestimateur H-T de la moyenne est \\(\\hat{\\overline{t} } = 1/N\\sum_{i=1}^n{z_i/\\pi_i}\\) \\(\\pi\\) est la probabilité quun site déchantillonnage soit inclu dans léchantillon (probabilité dinclusion) \\(z_i/\\pi_i\\) sappelle les valeurs étendues Cette formule fonctionne pour nimporte quel plan déchantillonnage avec \\(\\pi_i\\) connus Pour un SIR, la probabilité quun site soit choisi pour un tirage vaut \\(1/N\\) avec \\(n\\) tirage, elle vaut \\(\\pi_i = n/N\\) Le total peut donc être estimé par \\(N/n\\sum_{i=1}^n{z_i } = N \\hat{z}\\) 4.3.2 La moyenne pour la population discrète fini Avec le plan aléatoire simple, le calcul de la moyenne est très simple # simulation du terrain terrain2 &lt;- over(MonEch,champSP) MoyEst &lt;- mean(terrain2$sim1) MoyEst ## [1] 4.935534 A comparer avec la moyenne de la population \\(5.2986022\\) 4.3.3 La variance spatiale et variance déchantillonnage Ne confondez pas la variance spatiale et la variance déchantillonnage ! La variance spatiale (variance de population) est une caractéristique de la population La variance déchantillonnage est une caractéristique dune stratégie déchantillonnage, cest-à-dire une combinaison dun plan déchantillonnage et dun estimateur Son estimation dans le cas dun SIR pour une population dite infinie \\(\\hat{V}(\\hat{ \\overline{z} } ) = \\frac{\\hat{S^2}(z) } {n}\\) soit \\(\\hat{V}(\\hat{ \\overline{z} } ) = \\frac{1} {(n(n-1))} \\sum_{i=1}^n (z_i - \\hat{ \\overline{z} })\\) Mais lestimateur peut être utilisé pour les populations finie \\(\\hat{V}(\\hat{ \\overline{z} } ) = (1 - \\frac{n}N) \\frac{\\hat{S^2}(z) } {n}\\) avec \\((1 - \\frac{n}N)\\) correspondant à la correction pour les populations finies # Variance d&#39;échantillonnage de MoyEst V &lt;- var(terrain2$sim1) / n 4.3.4 linterval de confiance Le calcul de linterval de confiance sur la moyenne nécessite de faire une hypothèse sur la distribution de \\(\\hat{ \\overline{z} }\\) Pour le un nombre \\(n\\) grand (&gt;30) et si la distribution de la propirété dans lespace nest pas trop asymétrique, lhypothèse de normalité est réaliste Lintervalle de confiance à \\(100(1-\\alpha)\\) % est: \\(\\hat{ \\overline{z} }\\pm u_{1-\\alpha/2}.\\sqrt{V(\\hat{t^l}) }\\) où \\[u_{1-\\alpha/2}\\] est le \\((1-\\alpha/2)\\) quantile de la loi normale \\(u\\). \\(n\\) is the number of sampling observations to compute the mean, eg \\(n_h*H\\). Pour des \\(n\\) petit (&lt;30), la loi de Student est plus adaptée. on pbtient: \\(\\hat{ \\overline{z} }\\pm t_{1-\\alpha/2}^{(n-1)}.\\sqrt{V(\\hat{t^l}) }\\) où \\[t^{(n-1)}_{1-\\alpha/2}\\] est le \\((1-\\alpha/2)\\) quantile de la loi de Student \\(t\\) avec \\((n-1)\\) degrees of freedom. \\(n\\) is the number of sampling observations to compute the mean, eg \\(n_h*H\\). Voici comment le mettre en oeuvre dans R # calcul du quantile zalpha &lt;- qnorm(p = 1- (0.05/2), mean = 0, sd = 1) # si n est petit &lt; 30 talpha &lt;- qt(p = 1- (0.05/2) , df = n-1) # calcul de l&#39;interval de confiance selon les deux lois IC &lt;- zalpha * sqrt(V) ICT &lt;- talpha * sqrt(V) c(IC,ICT) ## [1] 0.3990766 0.4261695 # comme n&lt; 30, on garde ICT # Est-ce que la vraie moyenne est dans l&#39;IC student Moy &lt; MoyEst + ICT ## [1] TRUE Moy &gt; MoyEst - ICT ## [1] TRUE 2 *ICT ## [1] 0.8523391 cbind(MoyEst, ICbas = MoyEst - ICT, ICHaut =MoyEst + ICT, Moy) ## MoyEst ICbas ICHaut Moy ## [1,] 4.935534 4.509364 5.361703 5.298602 4.4 Simulations Dans cette partie, nous allons tenter dappréhender lincertitude de lestimation de lindicateur à travers la réalisation de plusieurs échantillonnages simulés de 20 échantillons. Pour cela, nous tirons au hasard 20 points 10000 fois et nous effectuons la jointure spatiale avec la couche SIG supposée représenter la réalité terrain. n = 20 rep = 10000 N = n * rep MonEch &lt;- spsample( champSP , N , type = &quot;random&quot;) # on récupère les valeurs de carbone terrainSimul &lt;- over(MonEch,champSP) On calcule ensuite, par réplication, les estimations de la moyenne, de la variance déchantillonnage et de lintervace de confiance de la moyenne. terrainSimul$id &lt;- rep(1:rep,n) MesMoys &lt;- aggregate(terrainSimul$sim1, by = list(terrainSimul$id), FUN = mean) MesVarsEch &lt;- aggregate(terrainSimul$sim1, by = list(terrainSimul$id), FUN = var) MesVarsEch$x &lt;- MesVarsEch$x / 20 MesStats &lt;- cbind.data.frame(MesMoys,MesVarsEch$x) colnames(MesStats) &lt;- c(&#39;Group&#39;,&#39;Moy&#39;,&#39;VarEch&#39;) MesStats$UCI &lt;- MesStats$Moy + talpha * sqrt(MesStats$VarEch) MesStats$LCI &lt;- MesStats$Moy - talpha * sqrt(MesStats$VarEch) Pour se rendre compte de lintervalle de confiance à 95 %, nous représentons sur le graphique suivant pour les 100 premiers tirages, les estimations de la moyenne, et de son intervalle. Nous représentons également la vraie moyenne calculée sur tous les pixels: \\(5.2986022\\) ggplot(MesStats[ MesStats$Group %in% 1:100 , ]) + geom_pointrange(size = 0.62, aes(x = Group, ymin = UCI, ymax = LCI, y = Moy)) + geom_abline(intercept = Moy, slope = 0, color = &quot;red&quot;) Figure 4.2: Représentation de lintervalle de confiance à 95 % et de la vraie moyenne en rouge pour chaque simulation Enfin, il est possible de calculer sur lensemble des réalisations, le nombre de fois que la vraie moyenne tombe en dehors de lintervalle de confiance. Ce qui donne : MesStats$test &lt;- ifelse(Moy &gt; MesStats$LCI, ifelse(Moy&lt; MesStats$UCI, 1,0), 0) 100* sum(MesStats$test)/rep ## [1] 94.82 OUI, 95 % comme attendu ! "],["léchantillonnage-aléatoire-stratifié.html", "Chapter 5 Léchantillonnage aléatoire stratifié 5.1 Pourquoi stratifier ? 5.2 Comment stratifier ? 5.3 Estimateurs STSI 5.4 Stratification géographique par strates compactes", " Chapter 5 Léchantillonnage aléatoire stratifié Pour ce type dapproche, la population ou la zone détude est subdivisée en sous-populations, appelées strates. Les strates ne peuvent pas se chevaucher, et leur union doit correspondre à la population étudiée. Dans chaque strate, un échantillon est sélectionné au hasard Les strates peuvent être échantillonnées de nombreuses manières, par exemple par échantillonnage aléatoire (SI). Cela conduit à un échantillonnage aléatoire simple stratifié (STSI) La méthode de sélection des unité par SI est appliquée à chaque strate séparément 5.1 Pourquoi stratifier ? Deux raisons possibles : Les estimations des paramètres statistiques pour la zone sont plus précises Nous voulons des estimations séparées des paramètres statistiques pour les sous-populations 5.2 Comment stratifier ? Deux approches : Stratification à laide dun variables auxiliaires Variable catégorielle (unités cartographiques) variable quantitative (par exemple, images de télédétection) Stratification par la position géographique uniquement (X et Y) 5.3 Estimateurs STSI Lestimateur de la moyenne STSI est le suivant \\(\\hat{ \\overline{z} } = \\sum_{h=1}^{H} w_h \\hat{\\overline{z} }_{h}\\) avec \\(w_h = A_h/\\sum_{h}A_h\\) et \\(\\hat{\\overline{z} }_{h}\\) est lestimateur SI de chaque strate \\(h\\) avec un échantillonnage aléatoire simple. La variance déchantillonnage de la moyenne expérimentale des \\(z\\) est : \\[\\begin{equation} V(\\hat{ \\overline{z^l} } ) = \\sum_{h=1}^{H} w_h^2 \\frac{ \\hat{ S^2_h} (\\hat{ \\overline{z^l} } ) }{n_h} \\end{equation}\\] où \\(\\hat{ S^2_h} (\\hat{ \\overline{z^l} })\\) est la variance SI dans la strate \\(h\\) : \\[\\begin{equation} \\hat{ S^2_h} (\\hat{ \\overline{z^l} })= \\frac{1}{n_h-1}\\sum_{i=1}^{n_h} ( z^l_{hi} -\\hat{\\overline{z}}_h^l ) \\end{equation}\\] 5.4 Stratification géographique par strates compactes Parfois, il nexiste pas dinformation a priori sur la variabilité spatiale de la propriété visée. Dans ce cas, une bonne répartition spatiale peut 5.4.1 Définition Dans cette approche, les \\(n\\) observations sont réparties de manière optimale au sein de la zone détude. Pour cela, on utilise un critère qui minimise la distance entre les observations et un discrétisation de la zone détude. La moyenne du carré de la plus courte distance au point j: \\(MCPCD_j = 1/N \\sum^N_{i=1}min_j(D_{ij}^2)\\) Le critère \\(MCPCD_j\\) peut être minmisé en utilisant lalgorithme des K-moyenne Il existe un package R spcosa de Walvoort, Brus, and Gruijter (2010). Dans cette appraoche, il nest pas nécessaire de définir un variogramme a priori pour loptimisation de la répartition des \\(n\\) observations. Les strates ainsi définies sont appelées Strates compactes 5.4.2 Estimateurs STSI Ici, comme les strates ont la même surface et donc le même poids, on peut simplifier les estimateurs En effet, on peut simplifier les poids : \\(w_h = A_h/\\sum_{h}A_h = 1/H\\) La moyenne: \\[\\begin{equation} \\hat{ \\overline{z} } = \\sum_{h=1}^{H} \\frac1H \\hat{\\overline{z} }_{h} \\end{equation}\\] et \\[\\begin{equation} \\hat{\\overline{z}}_{h} =\\frac1{n_h} \\sum_{i=1}^{n_h}z_i \\end{equation}\\] Si en plus le nombre dobservations est le même par strate (\\(n_h\\)), on obtient une formule assez simple \\[\\begin{equation} \\hat{ \\overline{z} } = \\frac1N \\sum_{i=1}^{N} z_i \\end{equation}\\] Pour la variance déchantillonnage, il en va de même. \\[\\begin{equation} V(\\hat{ \\overline{z^l} } ) = (\\frac1H)^2 \\sum_{h=1}^{H} \\frac{ \\hat{ S^2_h} (\\hat{ \\overline{z^l} } ) }{n_h} \\end{equation}\\] 5.4.3 Implémentation Il est conseillé de tirer au hasard 2 points par strate afin de pouvoir calculer une variance. Il suffit ensuite dadapter le nombre de strate pour atteindre le nombre dunités déchantillonnage visé. Avec cette méthode, on réparit au mieux les unités dans lespace. Ici, on avait retenu 20 unités, soit donc 10 strates. library(raster) champSP.r &lt;- raster(champSP) res(champSP.r) ## [1] 1 1 #aggregate from 1x1 resolution to 3x3 (factor = 3) champSP.r.aggregate &lt;- aggregate(champSP.r, fact = 2) res(champSP.r.aggregate) ## [1] 2 2 champSP.r.aggregate &lt;- as(champSP.r.aggregate , &quot;SpatialPixels&quot;) # compute compact geographical strata myStrata &lt;- stratify(champSP.r.aggregate, nStrata = 10, equalArea=TRUE, nTry=5 ) plot(myStrata) # obtain the surface areas of the strata print(areaStrata&lt;-getArea(myStrata)) ## 0 1 2 3 4 5 6 7 8 9 ## 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 # select randomly n locations from the strata mySample &lt;- spsample(myStrata, n = 2) plot(myStrata, mySample) Comparons les deux approches: SI et STSI avec strates compactes STSI &lt;- tm_shape(champSP) + tm_raster()+ tm_shape(mySample@sample)+ tm_symbols()+ tm_layout(legend.outside = TRUE) tmap_arrange(SI, STSI) ## Warning: The projection of the shape object champSP is not known, while it seems ## to be projected. ## Warning: Current projection of shape champSP unknown and cannot be determined. ## Warning: Current projection of shape MonEch unknown and cannot be determined. ## Warning: The projection of the shape object champSP is not known, while it seems ## to be projected. ## Warning: Current projection of shape champSP unknown and cannot be determined. ## Warning: Current projection of shape mySample@sample unknown and cannot be ## determined. ## Warning: The projection of the shape object champSP is not known, while it seems ## to be projected. ## Warning: Current projection of shape champSP unknown and cannot be determined. ## Warning: Current projection of shape MonEch unknown and cannot be determined. ## Warning: The projection of the shape object champSP is not known, while it seems ## to be projected. ## Warning: Current projection of shape champSP unknown and cannot be determined. ## Warning: Current projection of shape mySample@sample unknown and cannot be ## determined. Examinons ce que donne la simulation pour la moyenne terrainSTSI &lt;- over(mySample@sample,champSP) MoyEstSTSI &lt;- mean(terrainSTSI$sim1) MoyEstSTSI ## [1] 5.459981 Et pour la variance StratesSTSI &lt;- over(mySample@sample,myStrata@cells) myStrata@stratumId[StratesSTSI] ## [1] 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 Mydata &lt;- cbind.data.frame( strate = myStrata@stratumId[StratesSTSI], z= terrainSTSI$sim1 ) Varh&lt;-tapply(Mydata$z, INDEX=Mydata$strate,FUN=var) VStsi &lt;- (1/10^2) * sum(Varh/2) Voici donc la variance SI \\(0.0414588\\) et la variance dans ce cas \\(0.0271827\\) # calcul de l&#39;interval de confiance selon les deux lois ICT &lt;- talpha * sqrt(VStsi) # comme n&lt; 30, on garde ICT # Est-ce que la vraie moyenne est dans l&#39;IC student Moy &lt; MoyEstSTSI + ICT ## [1] TRUE Moy &gt; MoyEstSTSI - ICT ## [1] TRUE cbind(MoyEstSTSI, ICbas = MoyEstSTSI - ICT, ICHaut = MoyEstSTSI + ICT, Moy) ## MoyEstSTSI ICbas ICHaut Moy ## [1,] 5.459981 5.1149 5.805062 5.298602 References "],["SY-QUICK.html", "Chapter 6 Echantillonnage aléatoire systématique 6.1 Définitions 6.2 Exemple de grille 6.3 théorie 6.4 Exemple de mise en oeuvre", " Chapter 6 Echantillonnage aléatoire systématique 6.1 Définitions En matière déchantillonnage dans lespace, le type déchantillonnage appelé communément SY signifie un échantillonnage selon une grille régulière Plusieurs points doivent caractériser cette grille La grille est placée au hasard sur la zone. En général, on tire au hasard le point origine de la grille dans une zone de la résolution de la grille. Lorientation ne doit pas être aléatoire Dans les SY, les unités déchantillonnage sont très bien réparties au sein de la zone détude Avantage : (1) estimations précises du total, de la moyenne, de la proportion, et (2) il est possible de mettre en oeuvre des techniques de cartographie statistiques comme le krigeage. Inconvénient : ils nexiste pas destimateur non biaisé de la variance déchantillonnage fixer le nombre de points avec la résolution qui va dépndre du budget alloué au projet. 6.2 Exemple de grille MonEch &lt;- sp::spsample( x = champSP , cellsize = 20 , type = &quot;regular&quot;) set.seed(2) # ne marche pas sinon MonEch2 &lt;- sp::spsample( x = champSP , cellsize = 20 , type = &quot;regular&quot;) tm_shape(champSP) + tm_raster() + tm_shape(shp = MonEch) + tm_symbols(col=&#39;black&#39;) + tm_shape(shp = MonEch2) + tm_symbols(col=&#39;green&#39;)+ tm_layout(legend.outside = TRUE) Figure 6.1: Exemple de grilles systématiques placées au hasard 6.3 théorie La moyenne peut être calculé avec lestimateur SI 6.4 Exemple de mise en oeuvre Voici un exemple de mise en oeuvre des calculs proposés au paragraphe précédent. terrainSY &lt;- over(MonEch2, champSP) #change class of object with sample data to SpatialPixelsDataFrame gridded(MonEch2) &lt;- TRUE #compute number of strata from length of data file NB number of sampling units can be odd numberofStrata &lt;- floor(length(MonEch2) / 2) #cluster the sampling units myStrata &lt;- stratify(MonEch2, nStrata = numberofStrata, equalArea = TRUE, nTry = 100) myStrata.df &lt;- as(myStrata, &quot;data.frame&quot;) data &lt;- cbind(terrainSY, myStrata.df) varh &lt;- tapply(data$sim1, INDEX = data$stratumId, FUN = var) nh &lt;- tapply(data$sim1, INDEX = data$stratumId, FUN = length) varmeanh&lt;-varh/nh wh&lt;-nh/sum(nh) semeanSTSI&lt;-sqrt(sum(wh^2*varmeanh)) semeanSI &lt;- sqrt(var(terrainSY$sim1)/length(MonEch2)) Ainsi, lestimation de la variance déchantillonnage dite naïve est \\(0.1801523\\). Cette valeur est supérieure à la valeur fournie par lestimation avec le deuxième formule: \\(0.1292304\\) "],["CARTO.html", "Chapter 7 Echantillonnage pour la cartographie 7.1 Caractéristiques 7.2 Différents types de plans 7.3 La grille systématique 7.4 Echantillonnage spatial optimisé 7.5 Echantillonnage pour la géostatitique 7.6 Plan optimisé dans lespace des covariables", " Chapter 7 Echantillonnage pour la cartographie 7.1 Caractéristiques Lorsque les paramètres de la population (moyenne ou total, percentiles) à étudier ou pour plusieurs sous-régions nest pas suffisant La résolution spatiale requise pour la cartographie est bien plus importante que pour les statstisque globale Quelles Méthodes de cartographie : Méthodes dinterpolation spatiale heuristique : Polygones de Thiessen, triangulation, voisin naturel, distance inverse Interpolation spatiale basée sur un modèle stochastique : le krigeage Modèle non spatial : modèle de régression linéaire, arbre de régression, forêt aléatoire 7.2 Différents types de plans Echantillonnage pour la cartographie par interpolation spatiale Plans déchantillonnage géométriques Grilles régulières Échantillonnage de la couverture spatiale Plans déchantillonnage basés sur des modèles Echantillonnage pour la cartographie avec des modèles de régression ou par arbres de regression stratification de lespace des covariables Échantillonnage par hypercube latin 7.3 La grille systématique 7.3.1 Caractéristiques Facile à mettre en uvre Bonne couverture spatiale La grille ne doit pas être forcément placée au hasard Formes : carrées, triangulaires, hexagonales Pour choisir la résolution Le maximum de budget mobilisable Un seuil pour lerreur dinterpollation mais dans ce cas, il est nécessaire de poser des hypothèses sur un modèle de variabilité spatiale Avec un échantillonnage par grille régulière, la répartition des observations est fixe (carré, triangulaire) Avec des zones de forme irrégulière, la couverture spatiale est dans la plupart des cas sous-optimal. Elle amène souvent à des problème aux bordures en augmentant ainsi les effets de bords Une couverture spatiale sous-optimale devient plus problématique lorsque nous disposons de données existantes (données anciennes) En présence de données existantes, nous voulons remplir les espaces vides 7.3.2 Implémentation On teste ici les fonctions en prenant la parcelle du package spcosa Voici lexemple pour la grille de type régulière à maille carrée. On remarque la présence de zone sans donnée. # regular MagrilleReg &lt;- spsample( shpFarmsum , type = &quot;regular&quot;, cellsize = 30) tm_shape(shpFarmsum) + tm_borders( ) + tm_shape(MagrilleReg) + tm_symbols() Figure 7.1: Grille régulière Voici lexemple pour la grille de type régulière carré. On remarque la présence de zone sans donnée. MagrilleHex &lt;- spsample( shpFarmsum , type = &quot;hexagonal&quot;, cellsize = 30) tm_shape(shpFarmsum) + tm_borders( ) + tm_shape(MagrilleHex) + tm_symbols() Figure 7.2: Echantillonnage optimisé pour le krigeage 7.4 Echantillonnage spatial optimisé 7.4.1 Définition Dans cette approche, les \\(n\\) observations sont réparties de manière optimale au sein de la zone détude. Pour cela, on utilise un critère qui minimise la distance entre les observations et les points de la grille régulière de prédiction. La moyenne du carré de la plus courte distance au point j: \\(MCPCD_j = 1/N \\sum^N_{i=1}min_j(D_{ij}^2)\\) Le critère \\(MCPCD_j\\) peut être minmisé en utilisant lalgorithme des K-moyenne Il existe un package R spcosa de Walvoort, Brus, and Gruijter (2010). Dans cette appraoche, il nest pas nécessaire de définir un variogramme a priori pour loptimisation de la répartition des \\(n\\) observations. Les strates ainsi définies sont appelées Strates compactes 7.4.2 Mise en oeuvre avec spcosa La fonction stratify implémente la stratification dite par strate compacte. # initialize pseudo random number generator set.seed(700124) # stratify Farmsum into 50 strata myStratification &lt;- stratify(shpFarmsum, nStrata = 30) # plot stratification plot(myStratification) Sans option, la commande spcosa::spsample extrait le centroïde des strates obtenues par lalgorithme des K-moyennes. # sans option, la commande spcosa::spsample extrait le centroïde de la strate. mySamplingPattern &lt;- spsample(myStratification) # plot sampling pattern plot(myStratification, mySamplingPattern) 7.4.3 En présence de données existantes Supposons lexistance dun \\(k\\) échantillons sur la zone k= 20 set.seed(3) MonEchAncien &lt;- spsample( shpFarmsum , k , type = &quot;random&quot;) spplot(MonEchAncien) La commande spcosa::stratify permet de construire les strates compactes en tenant compte de ces observations afin doptimiser la répartition des échantillons supplémentaires pour la cartographie #Set number of new sampling locations to be selected n&lt;-100 #Compute total sample size (existing points + new points) ntot&lt;-n+k #Compute geostrata with option priorPoints=priordataEthiopia set.seed(314) myStrata &lt;- stratify(shpFarmsum, cellSize= 2 , nStrata = ntot, priorPoints=MonEchAncien, nTry=10) #Select sampling points of infill sample (centres of geostrata) mySample &lt;- spsample(myStrata) Voici la répartition des points. #Plot geostrata and sampling points (centres of geostrata) plot(myStrata, mySample) 7.5 Echantillonnage pour la géostatitique Dans une récente étude, Wadoux, Marchant, and Lark (2019) propose de rajouter 10 % du nombre total dobservations au plan par couverture spatiale optimisée. Ces points sont positionné à une petite distance de cette sélection au hasard de points. On définit premièremement la distance \\(d\\) (20 m dans cette exemple) et le nombre de points \\(m\\) (10 %) mySCsample.df &lt;- as(mySamplingPattern, &quot;data.frame&quot;) # on extrait ici les coordonnées h &lt;- 20 # Distance m &lt;- round( 0.1 * nrow(mySCsample.df)) + 1 On tire ensuite au hasard les \\(m\\) points et on calcule les nouvelles coordonnées afin de placer au hasard le nouveau points sur un cercle de rayon \\(d\\). # Specify separation distances and subsample sizes # Select random subsample from the spatial coverage sample set.seed(314) ids &lt;-sample(nrow(mySCsample.df), size = m) mySubsample &lt;- mySCsample.df[ids,] # Select locations in random direction at distances h from subsample plus &lt;- NULL dxy &lt;- matrix(nrow=m,ncol=2) angle&lt;-runif(n = m, min = 0, max = 2*pi ) dxy[,1] &lt;- h * sin(angle) dxy[,2] &lt;- h * cos(angle) plus.h&lt;-mySubsample+dxy mySCsample.df &lt;- rbind(mySCsample.df,plus.h) mySCsample.df$id &lt;- row.names(mySCsample.df) coordinates(mySCsample.df) &lt;- ~x1+ x2 Voici la représentation du plan déchantillonnage pour la géostatistique. tm_shape(shpFarmsum)+ tm_borders()+ tm_shape(mySCsample.df) + tm_symbols() Figure 7.3: Plan optimisé pour la géostatistique 7.6 Plan optimisé dans lespace des covariables 7.6.1 Définition Dans cette partie, léchantillons doit permettre de calibrer un modèle de regression avec des covariables spatialisées. Il existe de nombreuse méthodes pour sélectionner des unités déchantillonnage de sorte quelle permette d cLHS Surface response design 7.6.2 Données Comme présenté dans le chapitre sur les données, nous utilisons un jeu de données consitué de grille décrivant un ensemble de caractéristiques dune parcelle en Australie. #Read data with coordinates and other attributes of fine grid (discretization of study area) load(file=&quot;Data/HunterValley4Practicals.RData&quot;) grdHunterValley2 &lt;- grdHunterValley coordinates(grdHunterValley2) &lt;- c(&#39;Easting&#39;,&#39;Northing&#39;) gridded(grdHunterValley2) &lt;- TRUE tm_shape(grdHunterValley2) + tm_raster(col = c(&quot;elevation_m&quot;,&quot;slope_deg&quot;,&quot;cti&quot;,&quot;ndvi&quot;) ) ## Warning: The projection of the shape object grdHunterValley2 is not known, while ## it seems to be projected. ## Warning: Current projection of shape grdHunterValley2 unknown and cannot be ## determined. ## Variable(s) &quot;ndvi&quot; contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette. 7.6.3 Mise en oeuvre avec lalgorithme K-moyennes #Set number of sampling locations to be selected n&lt;-20 #Compute clusters set.seed(314) myClusters &lt;- kmeans(scale(grdHunterValley[,c(3,4,6,7)]), centers=n, iter.max=100,nstart=10) grdHunterValley$clusters &lt;- myClusters$cluster #Select locations closest to the centers of the clusters rdist.out &lt;- rdist(x1=myClusters$centers,x2=scale(grdHunterValley[,c(3,4,5,6,7)])) ids.mindist &lt;- apply(rdist.out,MARGIN=1,which.min) mySample &lt;- grdHunterValley[ids.mindist,] Dans cette Il est possible de représenter les unités déchantillonnage dans lespace géographique: ggplot(grdHunterValley) + geom_tile(mapping = aes(x = Easting, y = Northing, fill = factor(clusters))) + scale_fill_discrete(name = &quot;cluster&quot;) + geom_point(data=mySample,mapping=aes(x=Easting,y=Northing),size=2) + scale_x_continuous(name = &quot;&quot;) + scale_y_continuous(name = &quot;&quot;) + coord_fixed() + theme(legend.position=&quot;none&quot;) Figure 7.4: Plan optimisé par K-moyenne sur les covariables, représentation dans lespace géographique Mais également dans lespace des covariables. Ici, on retient laltitude et le CTI. ggplot(grdHunterValley) + geom_point(mapping=aes(y=elevation_m,x=cti,colour=factor(clusters)), size = .51) + geom_point(data=mySample,mapping=aes(y=elevation_m,x=cti),size=1.5) + scale_y_continuous(name = &quot;Elevation&quot;) + scale_x_continuous(name = &quot;ndvi&quot;) + theme(legend.position=&quot;none&quot;) Figure 7.5: Plan optimisé par K-moyenne sur les covariables, représentation dans lespace des covariables ggplot(grdHunterValley) + geom_point(mapping=aes(y=elevation_m,x=slope_deg,colour=factor(clusters)), size = .51) + geom_point(data=mySample,mapping=aes(y=elevation_m,x=cti),size=1.5) + scale_y_continuous(name = &quot;Elevation&quot;) + scale_x_continuous(name = &quot;Slope&quot;) + theme(legend.position=&quot;none&quot;) Figure 7.6: Plan optimisé par K-moyenne sur les covariables, représentation dans lespace des covariables References "],["Script.html", "Chapter 8 Script final", " Chapter 8 Script final Ce chapitre rassemble lensemble des commandes utilisées dans un script fonctionnel. setwd(&quot;C:/Users/nsaby/Dropbox/fac/tp/sampling/&quot;) # R # Probablity sampling : SI, STSI (spatial et covariable), SY # impl?menter le workflow dans R/ArcGis avec vecteur et rasteur # Calculer la moyenne par SI, STSI et SY # MB sampling : grid, infill sampling # # test 1 avec des ?chantillonnage al?atoire -------------- library(sp) library(tmap) # library(maptools) # library(mapview) # library(rgdal) champ &lt;- read.csv(&#39;./data/simulatedField_1Exp25.csv&#39;) # Simuler une Aléatoire Simple (SI) n = 100 # Creation des identifiants des lignes id = 1:10000 # ou id = seq( from = 1, to = 10000, by = 1) # tire au hasard n valeurs parmi 10000 MesIds &lt;- sample( x = id , size = n) MesIds &lt;- sort(MesIds) # Les coordonn?es champ[MesIds,1:2] # Extraire les valeurs de carbone, simuler le terrain terrain &lt;- champ[ MesIds, &quot;sim1&quot; ] # moyenne estim?e ? partir de l&#39;?chantillon MoyEst &lt;- mean(terrain) # Variance d&#39;?chantillonnage de MoyEst V &lt;- var(terrain) / n # vraie moyenne Moy &lt;- mean(champ$sim1) # calcul du quantile z &lt;- qnorm(p = 1- (0.05/2), mean = 0, sd = 1) # si n est petit &lt; 30 z &lt;- qt(p = 1- (0.05/2) , df = 20-1) # calcul de l&#39;interval de confiance IC &lt;- z * sqrt(V) # Est-ce que la vraie moyenne est dans l&#39;IC Moy &lt; MoyEst + IC Moy &gt; MoyEst - IC 2 *IC cbind(MoyEst, ICbas = MoyEst - IC, ICHaut =MoyEst + IC, Moy) # Tester le package sp ------ library(sp) # Copie du tableau dans un nouvel objet champSP &lt;- champ # transformer en un raster coordinates(champSP) &lt;- c(&#39;s1&#39;,&#39;s2&#39;) # structure de l&#39;objet str(champSP) spplot(champSP) # transforme en raster le semi de points gridded(champSP) &lt;- TRUE spplot(champSP) str(champSP) # SI MonEch &lt;- spsample( champSP , n , type = &quot;random&quot;) plot(champSP) points(MonEch, pch = 3) # regular MonEch &lt;- spsample( champSP , type = &quot;regular&quot;, cellsize = 10) plot(champSP) points(MonEch, pch = 3) "],["references.html", "References", " References "]]
