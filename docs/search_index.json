[["index.html", "Cours Echantillonnage pour létude des propriétés du sol Chapter 1 Pourquoi ce cours 1.1 Motivations 1.2 Définition 1.3 Contenu 1.4 Objectifs de létude 1.5 LEchantillonnage Probabiliste 1.6 Population discrète et population continue 1.7 Libraries utilisées", " Cours Echantillonnage pour létude des propriétés du sol Nicolas Saby, INRAe Infosol 2021-01-07 Chapter 1 Pourquoi ce cours 1.1 Motivations Les motivations pour ce cours sont les suivantes: Les cours de statistique classique ne sattardent pas sur la discipline de léchantillonnage La conception dun protocole déchantillonnage efficace et efficient est une première étape importante dun projet de recherche Le plan déchantillonnage détermine en grande partie la qualité du résultat final Les problèmes dinférence statistique peuvent souvent être évités lorsque la réflection commence avant que les données ne soient collectées 1.2 Définition Le plan déchantillonnage dune enquête par sondage se réfère aux techniques utilisées pour sélectionner un échantillon probabiliste et aux méthodes utilisées pour obtenir des estimations des variables étudiées à partir de léchantillon sélectionné. 1.3 Contenu Proposer une vue densemble des différents plans déchantillonnage pour létude des milieux Connaissance des types de conception de base pour léchantillonnage aléatoire : avantages et inconvénients et des types de conception déchantillonnage dans lespace plus avancés Connaissance de la manière dont les informations annexes peuvent être utilisées dans le plan déchantillonnage ou dans linférence statistique. Connaissance de la manière dont les échantillons peuvent être sélectionnés dans R, et comment les paramètres statistiques peuvent être estimés et de la manière dont un plan déchantillonnage peut être évalué ex ante avant la collecte des données Ce cours est basé sur les travaux publié dans le livre (Gruijter et al. 2006). Les codes R sont également disponibles dans larticle de Brus et al (Brus 2019) 1.4 Objectifs de létude Objectifs possibles de létude Pour estimer des statistiques sommaires (moyenne, total, proportion) ou la fonction de distribution cumulative spatiale (SCDF) pour létude la zone (population) dans son ensemble La même chose, mais maintenant pour plusieurs sous-domaines Pour cartographier la variable dintérêt Nous ne sommes pas intéressés par les changements au fil du temps La propriété dintérêt ne change pas pendant la période denquête 1.5 LEchantillonnage Probabiliste Pour estimer les totaux ou les moyennes, léchantillonnage probabiliste est le plus approprié Par échantillonnage probabiliste, on entend un échantillonnage aléatoire tel que Toutes les unités de population ont une probabilité &gt; 0 dêtre sélectionnées Les probabilités dinclusion sont connues NB Les probabilités dinclusion ne doivent pas forcément être égales ! Il existe de nombreuses façons de sélectionner les unités de population avec un échantillonnage probabiliste 1.6 Population discrète et population continue Nous devons bien distinguer deux types de populations : Les populations discrètes : les objets naturels discrets correspondent naturellement aux unités déchantillonnage. Le nombre total dunités déchantillonnage dans la population (\\(N\\)) est finie Populations continues : les unités déchantillonnage doivent être définies, par exemple carrés de 1 km × 1 km Mais Nombre total dunités déchantillonnage dans une population continue peut être finie ou infinie Fini : tous les carrés disjoints de 1 km multipliés par 1 km dans une zone Infini : points dans une zone 1.7 Libraries utilisées Nous avons besoin des librairies suivantes library(sp) library(tmap) ## Warning: le package &#39;tmap&#39; a été compilé avec la version R 4.0.3 ## Warning: replacing previous import &#39;vctrs::data_frame&#39; by &#39;tibble::data_frame&#39; ## when loading &#39;dplyr&#39; library(rgdal) ## rgdal: version: 1.5-12, (SVN revision 1018) ## Geospatial Data Abstraction Library extensions to R successfully loaded ## Loaded GDAL runtime: GDAL 3.0.4, released 2020/01/28 ## Path to GDAL shared files: D:/nsaby/R/win-library/4.0/rgdal/gdal ## GDAL binary built with GEOS: TRUE ## Loaded PROJ runtime: Rel. 6.3.1, February 10th, 2020, [PJ_VERSION: 631] ## Path to PROJ shared files: D:/nsaby/R/win-library/4.0/rgdal/proj ## Linking to sp version:1.4-2 ## To mute warnings of possible GDAL/OSR exportToProj4() degradation, ## use options(&quot;rgdal_show_exportToProj4_warnings&quot;=&quot;none&quot;) before loading rgdal. library(ggplot2) References "],["data.html", "Chapter 2 Données", " Chapter 2 Données Nous basons nos exercices sur une réalité simulée dune valeur de carbone dans un parcelle agricole. Ce champ a été simulé en utilisant des techniques géostastitques. Lobjet correspond à un tableau comportant 3 colonnes. les coordonnées avec s1 et s2 les valeurs simulées sim1 Chaque coordonnée correspond au centre dun pixel champ &lt;- read.csv(&#39;data/simulatedField_1Exp25.csv&#39;) head(champ) ## s1 s2 sim1 ## 1 0.5 0.5 7.184881 ## 2 1.5 0.5 7.366762 ## 3 2.5 0.5 7.417718 ## 4 3.5 0.5 7.305573 ## 5 4.5 0.5 7.373427 ## 6 5.5 0.5 7.161203 Il est donc facile de transformer le tableau en une grille de type SpatialPixelsDataframe. Pour cela, on passe par une structure de type SpatialPointDataframe dans un premier temps. champSP &lt;- champ # transformer en un raster coordinates(champSP) &lt;- c(&#39;s1&#39;,&#39;s2&#39;) gridded(champSP) &lt;- TRUE Voici la structure de lobjet de type sp. # structure de l&#39;objet str(champSP) ## Formal class &#39;SpatialPixelsDataFrame&#39; [package &quot;sp&quot;] with 7 slots ## ..@ data :&#39;data.frame&#39;: 10000 obs. of 1 variable: ## .. ..$ sim1: num [1:10000] 7.18 7.37 7.42 7.31 7.37 ... ## ..@ coords.nrs : num(0) ## ..@ grid :Formal class &#39;GridTopology&#39; [package &quot;sp&quot;] with 3 slots ## .. .. ..@ cellcentre.offset: Named num [1:2] 0.5 0.5 ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;s1&quot; &quot;s2&quot; ## .. .. ..@ cellsize : Named num [1:2] 1 1 ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;s1&quot; &quot;s2&quot; ## .. .. ..@ cells.dim : Named int [1:2] 100 100 ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;s1&quot; &quot;s2&quot; ## ..@ grid.index : int [1:10000] 9901 9902 9903 9904 9905 9906 9907 9908 9909 9910 ... ## ..@ coords : num [1:10000, 1:2] 0.5 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5 ... ## .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. ..$ : NULL ## .. .. ..$ : chr [1:2] &quot;s1&quot; &quot;s2&quot; ## ..@ bbox : num [1:2, 1:2] 0 0 100 100 ## .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. ..$ : chr [1:2] &quot;s1&quot; &quot;s2&quot; ## .. .. ..$ : chr [1:2] &quot;min&quot; &quot;max&quot; ## ..@ proj4string:Formal class &#39;CRS&#39; [package &quot;sp&quot;] with 1 slot ## .. .. ..@ projargs: chr NA Il est assez simple de faire une carte avec le package tmap tm_shape(champSP) + tm_raster()+ tm_layout(legend.outside = TRUE) ## Warning: The projection of the shape object champSP is not known, while it seems ## to be projected. ## Warning: Current projection of shape champSP unknown and cannot be determined. Figure 2.1: Notre réalité: un champ aléatoire simulé avec un variogramme de type exponentiel Lhistogramme de la propriété ressemble à ceci: ggplot(champ, aes(x=sim1)) + geom_histogram(bins = 50) Figure 2.2: Histogramme de la population La moyenne vraie de la population vaut ainsi Moy = mean(champ$sim1) Moy ## [1] 5.298602 "],["SI.html", "Chapter 3 Echantillonnage aléatoire simple 3.1 Définition 3.2 Mise en oeuvre avec un logiciel 3.3 Calcul des estimateurs 3.4 Simulations", " Chapter 3 Echantillonnage aléatoire simple 3.1 Définition Les unités sont sélectionnées avec une probabilité égale et indépendamment les unes des autres ; également appelé échantillonnage aléatoire indépendant (IRS) Deux sous-types : avec remise (SIR) sans remise (SI) Cette distinction nest pas pertinente pour des populations infinies Toutes les combinaisons de \\(n\\) unités de population (tous les échantillons de \\(n\\) unités) ont une probabilité égale dêtre sélectionnés 3.2 Mise en oeuvre avec un logiciel 3.2.1 Excel Voici la procédure 3.2.2 Avec R pour les polutations discrètes Voici comment tirer au hasard des position dans lespace à partir de la liste des pixels. n = 20 #fixer la graine pour les tirages aléatoires set.seed(5601) # Creation des identifiants des lignes id = 1:10000 # ou id = seq( from = 1, to = 10000, by = 1) # tire au hasard n valeurs parmi 10000 MesIds &lt;- sample( x = id , size = n) MesIds &lt;- sort(MesIds) # Les coordonn?es champ[MesIds,1:2] ## s1 s2 ## 55 54.5 0.5 ## 179 78.5 1.5 ## 906 5.5 9.5 ## 1107 6.5 11.5 ## 3134 33.5 31.5 ## 3385 84.5 33.5 ## 3717 16.5 37.5 ## 3998 97.5 39.5 ## 4561 60.5 45.5 ## 4732 31.5 47.5 ## 4791 90.5 47.5 ## 5400 99.5 53.5 ## 5842 41.5 58.5 ## 6368 67.5 63.5 ## 6591 90.5 65.5 ## 6833 32.5 68.5 ## 7180 79.5 71.5 ## 7205 4.5 72.5 ## 8110 9.5 81.5 ## 8796 95.5 87.5 Il est possible alors dextraire les valeurs de carbone simulée pour les pixels tirés au hasard terrain1 &lt;- champ[ MesIds, &quot;sim1&quot; ] terrain1 ## [1] 3.787593 4.517748 5.593242 5.860584 4.784483 5.857722 4.707472 6.158010 ## [9] 5.834871 5.158347 5.672356 5.406237 5.295240 5.727957 5.237833 5.217027 ## [17] 5.694664 6.798903 5.808038 5.244798 3.2.3 Avec R pour les populations continues 1 Déterminer les coordonnées minimales et maximales s1 et s2 du domaine (boîte englobante) 2 Tirez deux coordonnées (pseudo-)aléatoires indépendantes \\(s_{1,v}\\) et \\(s_{2,aleat}\\) 3. Utilisez une routine de point dans le polygone pour déterminer si (s_{1,v}\\(,\\)s_{2,aleat}$) tombe dans la zone 4. Répétez les étapes 2 et 3 jusquà ce que n positions soient sélectionnées Le package sp offre la fonction spsample pour effectuer cette procédure à partir de couches SIG. MonEch &lt;- spsample( champSP , n , type = &quot;random&quot;) tm_shape(champSP) + tm_raster()+ tm_shape(MonEch)+ tm_symbols()+ tm_layout(legend.outside = TRUE) ## Warning: The projection of the shape object champSP is not known, while it seems ## to be projected. ## Warning: Current projection of shape champSP unknown and cannot be determined. ## Warning: Current projection of shape MonEch unknown and cannot be determined. 3.3 Calcul des estimateurs Dans cette partie nous explorons les techniques pour calculer les estimateurs des paramètres statistiques à partir des données collectées. 3.3.1 lestimateur de Horvitz-Thompson Lestimateur H-T du total est \\(\\hat t = \\sum{z_i/\\pi_i}\\) Lestimateur H-T de la moyenne est \\(\\hat t = 1/N\\sum_{i=1}^n{z_i/\\pi_i}\\) \\(\\pi\\) est la probabilité quun site déchantillonnage soit inclu dans léchantillon (probabilité dinclusion) \\(z_i/\\pi_i\\) sappelle les valeurs étendues Cette formule fonctionne pour nimporte quel plan déchantillonnage avec \\(\\pi_i\\) connus Pour un SIR, la probabilité quun site soit choisi pour un tirage vaut \\(1/N\\) avec \\(n\\) tirage, elle vaut \\(\\pi_i = n/N\\) Le total peut donc être estimé par $N/n_{i=1}^n{z_i } = N $ 3.3.2 La moyenne pour la population discrète fini Avec le plan aléatoire simple, le calcul de la moyenne est très simple # simulation du terrain terrain2 &lt;- over(MonEch,champSP) MoyEst &lt;- mean(terrain2$sim1) MoyEst ## [1] 5.493303 A comparer avec la moyenne de la population R Moy 3.3.3 La variance spatiale et variance déchantillonnage Ne confondez pas la variance spatiale et la variance déchantillonnage ! La variance spatiale (variance de population) est une caractéristique de la population La variance déchantillonnage est une caractéristique dune stratégie déchantillonnage, cest-à-dire une combinaison dun plan déchantillonnage et dun estimateur Son estimation dans le cas dun SIR pour une population dite infinie \\(\\hat{V}(\\hat{ \\overline{z} } ) = \\frac{\\hat{S^2}(z) } {n}\\) soit \\(\\hat{V}(\\hat{ \\overline{z} } ) = \\frac{1} {(n(n-1))} \\sum_{i=1}^n (z_i - \\hat{ \\overline{z} })\\) Mais lestimateur peut être utilisé pour les populations finie \\(\\hat{V}(\\hat{ \\overline{z} } ) = (1 - \\frac{n}N) \\frac{\\hat{S^2}(z) } {n}\\) avec \\((1 - \\frac{n}N)\\) correspondant à la correction pour les populations finies # Variance d&#39;échantillonnage de MoyEst V &lt;- var(terrain2$sim1) / n 3.3.4 linterval de confiance Le calcul de linterval de confiance sur la moyenne nécessite de faire une hypothèse sur la distribution de \\(\\hat{ \\overline{z} }\\) Pour le un nombre \\(n\\) grand (&gt;30) et si la distribution de la propirété dans lespace nest pas trop asymétrique, lhypothèse de normalité est réaliste Lintervalle de confiance à \\(100(1-\\alpha)\\) % est: \\(\\hat{ \\overline{z} }\\pm u_{1-\\alpha/2}.\\sqrt{V(\\hat{t^l}) }\\) où \\[t^{(n-1)}_{1-\\alpha/2}\\] est le \\((1-\\alpha/2)\\) quantile de la loi de Student \\(t\\) avec \\((n-1)\\) degrees of freedom. \\(n\\) is the number of sampling observations to compute the mean, eg \\(n_h*H\\). Pour des \\(n\\) petit (&lt;30), la loi de Student est plus adaptée. on pbtient: \\(\\hat{ \\overline{z} }\\pm t_{1-\\alpha/2}^{(n-1)}.\\sqrt{V(\\hat{t^l}) }\\) où \\[t^{(n-1)}_{1-\\alpha/2}\\] est le \\((1-\\alpha/2)\\) quantile de la loi de Student \\(t\\) avec \\((n-1)\\) degrees of freedom. \\(n\\) is the number of sampling observations to compute the mean, eg \\(n_h*H\\). Voici comment le mettre en oeuvre dans R # calcul du quantile zalpha &lt;- qnorm(p = 1- (0.05/2), mean = 0, sd = 1) # si n est petit &lt; 30 talpha &lt;- qt(p = 1- (0.05/2) , df = n-1) # calcul de l&#39;interval de confiance IC &lt;- zalpha * sqrt(V) ICT &lt;- talpha * sqrt(V) c(IC,ICT) ## [1] 0.3448016 0.3682098 # Est-ce que la vraie moyenne est dans l&#39;IC Moy &lt; MoyEst + IC ## [1] TRUE Moy &gt; MoyEst - IC ## [1] TRUE 2 *IC ## [1] 0.6896031 cbind(MoyEst, ICbas = MoyEst - IC, ICHaut =MoyEst + IC, Moy) ## MoyEst ICbas ICHaut Moy ## [1,] 5.493303 5.148501 5.838104 5.298602 3.4 Simulations Dans cette partie, nous allons tenter dappréhender lincertitude de lestimation de lindicateur à travers la réalisation de plusieurs échantillonnages simulés de 20 échantillons. Pour cela, nous tirons au hasard 20 points 10000 fois et nous effectuons la jointure spatiale avec la couche SIG supposée représenter la réalité terrain. n = 20 rep = 10000 N = n * rep MonEch &lt;- spsample( champSP , N , type = &quot;random&quot;) # on récupère les valeurs de carbone terrainSimul &lt;- over(MonEch,champSP) On calcule ensuite, par réplication, les estimations de la moyenne, de la variance déchantillonnage et de lintervace de confiance de la moyenne. terrainSimul$id &lt;- rep(1:rep,n) MesMoys &lt;- aggregate(terrainSimul$sim1, by = list(terrainSimul$id), FUN = mean) MesVarsEch &lt;- aggregate(terrainSimul$sim1, by = list(terrainSimul$id), FUN = var) MesVarsEch$x &lt;- MesVarsEch$x / 20 MesStats &lt;- cbind.data.frame(MesMoys,MesVarsEch$x) colnames(MesStats) &lt;- c(&#39;Group&#39;,&#39;Moy&#39;,&#39;VarEch&#39;) MesStats$UCI &lt;- MesStats$Moy + talpha * sqrt(MesStats$VarEch) MesStats$LCI &lt;- MesStats$Moy - talpha * sqrt(MesStats$VarEch) Pour se rendre compte de lintervalle de confiance à 95 %, nous représentons sur le graphique suivant pour un nombre limité de tirage les estimations de la moyenne, et de son intervalle. Nous représentons également la vraie moyenne calculée sur tous les pixels R Moy ggplot(MesStats[ MesStats$Group %in% 1:100 , ]) + geom_pointrange(size = 0.62, aes(x = Group, ymin = UCI, ymax = LCI, y = Moy)) + geom_abline(intercept = Moy, slope = 0, color = &quot;red&quot;) Figure 3.1: Représentation de lintervalle de confiance à 95 % et de la vraie moyenne en rouge pour chaque simulation Enfin, il est possible de calculer sur lensemble des réalisations, le nombre de fois que la vraie moyenne tombe en dehors de lintervalle de confiance. Ce qui donne : MesStats$test &lt;- ifelse(Moy &gt; MesStats$LCI, ifelse(Moy&lt; MesStats$UCI, 1,0), 0) 100* sum(MesStats$test)/rep ## [1] 94.93 OUI, 95 % comme attendu ! "],["stsi.html", "Chapter 4 STSI", " Chapter 4 STSI "],["SY-QUICK.html", "Chapter 5 Echantillonnage systématique", " Chapter 5 Echantillonnage systématique "],["final-words.html", "Chapter 6 Final Words", " Chapter 6 Final Words We have finished a nice book. "],["references.html", "References", " References "]]
